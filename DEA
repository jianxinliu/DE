package dea;

import java.util.*;


//interface function{
//    static int Dimension = 30;
//    static int max=100;
//    static int min = -100;
//    
//    public abstract void function1();
//    public abstract void FitForFunction();
//    
//}

/**
 * 2016/05/09 重写
 */
public class DEA {

    //定义一个二维数组，装初始种群
    private static double[][] x;
    //变异操作后存放种群
    private static double[][] v;
    //交叉操作后存放种群
    private static double[][] u;
    //选择操作后，的当代最优种群
    private static double[][] x_;
    //问题维度                                                                    维度不应该是算法的类成员变量，而也应该是函数的类属性
    private static int D;
    //缩放因子
    private static double F;
    //交叉概率
    private static double CR;
    //种群规模（个体个数）
    private static int NP;
    //需要进化的代数
    private static int G;
    //当前迭代次数
    private static int g;
    //当前最优个体
    private static double[] BestIndividual;
    //当前最优个体的函数适应值
    private static double BestFitValue;

    /**
     * 构造函数
     */
    //                                                                             D的初始化需要交给抽象类function
    public DEA(int np, int d, int gen,double f,double cr) {
        this.F = f;
        this.CR = cr;
        this.NP = np;
        this.D = d;
        this.G = gen;
    }

    /**
     * 目标函数，获取一个x，返回函数值
     *                                                                         此处的函数不应该是一个具体的函数，而应该是一个接口，用于不同的函数
     */
    private double function(double x) {
        return x*x;
    }
    

    /**
     * 求适应值，接受一个一维数组arr， 函数将数组里的每一个元素代入function 
     * 返回所有元素的函数值的和(个体的适应值)
     *                                                                          适应值函数应该是function的方法，也应该是一个接口
     */
    private double fitness(double[] arr) {
        double sum = 0;
        for (int i = 0; i < arr.length; i++) {
            sum += function(arr[i]);
        }
        return sum;
    }

    /**
     * 求最优适应值，接受一个HasMap，升序排序其key，输出最优key值(函数适应值)
     */
    private double BestFitness(TreeMap fitness) {
        TreeMap<Double, Integer> map = fitness;
        return map.firstKey();
    }

    /**
     * 由最优值(key)-->其对应的value(个体所在的位置)-->找到个体
     */
    private double[] findIndividualWithFit(double a, TreeMap s, double[][] arr) {
        double[] best = new double[D];
        TreeMap<Double, Integer> Map = s;
        best = arr[Map.get(a)];
        return best;
    }

    /**
     * max min为上下界约束 初始化种群
     *                                                                           min,max应该是函数的属性
     */
    public void original(int max, int min) {
        TreeMap<Double, Integer> map = new TreeMap<>();
        //当前种群中所有个体的函数适应值
        double[] fitValue = new double[D];
       //由最优适应值可知当前种群最优个体(初始化阶段可直接将当前最优个体交给BestIndividual)
        x = new double[NP][D];
        for (int i = 0; i < x.length; i++) {
            for (int j = 0; j < x[i].length; j++) {
                x[i][j] = min + (Math.random() * (max - min));
            }
           //生成个体时，每生成一个就求其适应值，并作为map中的key，对应的value为个体所在的位置i
            map.put(fitness(x[i]), i);
        }
        BestFitValue = BestFitness(map);
        //初始化完成-->HashMap添加完成，对其key排序，选出最优的，得到其对应的个体
        BestIndividual = findIndividualWithFit(BestFitness(map), map, x);

    }

    /**
     * 变异操作 f为缩放因子
     */
    public void variation() {
        int i1;
        int i2;
        int i3;
        v = new double[NP][D];
        //嵌套for循环
        for (int i = 0; i < v.length; i++) {
            i1 = (int) (Math.random() * v.length);
            while (i1 == i) {
                i1 = (int) (Math.random() * v.length);
            }
            i2 = (int) (Math.random() * v.length);
            while (i2 == i1 || i2 == i) {
                i2 = (int) (Math.random() * v.length);
            }
            i3 = (int) (Math.random() * v.length);
            while (i3 == i2 || i3 == i1 || i3 == i) {
                i3 = (int) (Math.random() * v.length);
            }

            for (int j = 0; j < v[i].length; j++) {
                v[i][j] = x[i1][j] + F * (x[i2][j] - x[i3][j]);
            }
        }
    }

    /**
     * 交叉操作 cr为交叉概率
     */
    public void hybird() {
        u = new double[NP][D];
        for (int i = 0; i < u.length; i++) {
            //此处的随机数Ri在每行也应该是相等的
            int Ri = (int) (1 + (Math.random() * (D - 1)));
            for (int j = 0; j < u[i].length; j++) {
                if (Math.random() < CR || j == Ri) {
                    u[i][j] = v[i][j];
                } else {
                    u[i][j] = x[i][j];
                }
            }
        }
    }

    /**
     * 选择操作
     */
    public void choice() {
        x_ = new double[NP][D];
        //通过适应值来进行选择操作
        for (int i = 0; i < x_.length; i++) {
            if (fitness(u[i]) <= fitness(x[i])) {
                x_[i] = u[i];
            } else {
                x_[i] = x[i];
            }
        }
    }

    /**
     * 交接(过渡)操作，将上一代的x_移交给下一代的x, 并得出x_的最优个体,并进行比较，更替BestFitValue
     */
    public void transition() {
        double currentBestFit;
        double[] currentBestIndividual = new double[D];
        TreeMap<Double, Integer> mapx = new TreeMap<>();
        for (int i = 0; i < x.length; i++) {
            for (int j = 0; j < x[i].length; j++) {
                x[i][j] = x_[i][j];
            }
            //用Varition的方法求最优值及最优个体
            mapx.put(fitness(x[i]), i);
        }
        //一代进化完成后的最优个体的函数适应值
        currentBestFit = BestFitness(mapx);
        // 一代进化完成后的最优个体
        currentBestIndividual = findIndividualWithFit(BestFitness(mapx), mapx, x_);
        if (currentBestFit < BestFitValue) {
            BestFitValue = currentBestFit;
            BestIndividual = currentBestIndividual;
        }
       System.out.print("currentBestFit:" + currentBestFit + " ");
       System.out.println("BestFitValue:"+BestFitValue);

    }

    /**
     * Algorithm start 
     */
    public void DEAStart() {
        original(100, -100);
        for (g = 1; g <= G; g++) {
            System.out.println(g);
            variation();
            hybird();
            choice();
            transition();
        }
        System.out.println(BestFitValue);
        for (int i = 0; i < BestIndividual.length; i++) {
            System.out.println(BestIndividual[i]);
        }
    }
}
